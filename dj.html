<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dijkstra Visualizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center">
  <div class="p-6 bg-gray-800 rounded-xl shadow-xl w-[1400px]">
    <div class="flex gap-6">
      <!-- Sidebar -->
      <div class="w-64 flex flex-col gap-4">
        <h2 class="text-2xl font-bold mb-2">Dijkstra Visualizer</h2>
        <label>
          Start Node:
          <select id="start" class="w-full text-black rounded p-2 mt-1"></select>
        </label>
        <label>
          End Node:
          <select id="end" class="w-full text-black rounded p-2 mt-1"></select>
        </label>
        <button id="run" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded">Run</button>
        <button id="reset" class="bg-gray-400 hover:bg-gray-500 text-white py-2 px-4 rounded">Reset</button>
        <p id="pathDisplay" class="text-sm text-gray-300 mt-4">Shortest Path: </p>
      </div>

      <!-- Graph Area -->
      <div class="flex-1">
        <svg id="graph" width="1000" height="700" class="rounded bg-gray-700 shadow"></svg>
      </div>
    </div>
  </div>

<script>
const positions = [
  {x: 100, y: 350}, {x: 200, y: 250}, {x: 200, y: 450},
  {x: 300, y: 350}, {x: 400, y: 150}, {x: 400, y: 350},
  {x: 400, y: 550}, {x: 600, y: 250}, {x: 600, y: 450}, {x: 750, y: 350},
];

const edges = [
  [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3], [2, 6],
  [3, 4], [3, 5], [3, 6], [4, 5], [4, 7], [5, 6], [5, 7], [5, 8], [6, 8], [7, 9], [8, 9]
];

let graph = Array.from({ length: 10 }, () => Array(10).fill(Infinity));
edges.forEach(([u, v]) => {
  const w = Math.floor(Math.random() * 20) + 5;
  graph[u][v] = w;
  graph[v][u] = w;
});

class PriorityQueue {
  constructor() { this.data = []; }
  enqueue(val, pri) {
    this.data.push({ val, pri });
    this.data.sort((a, b) => a.pri - b.pri);
  }
  dequeue() { return this.data.shift()?.val; }
  isEmpty() { return this.data.length === 0; }
}

let animPath = [];

function drawGraph(highlighted = [], distMap = []) {
  const svg = document.getElementById("graph");
  svg.innerHTML = "";

  for (let [u, v] of edges) {
    const p1 = positions[u];
    const p2 = positions[v];
    const isHighlighted = highlighted.includes(`${u}-${v}`) || highlighted.includes(`${v}-${u}`);
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", p1.x);
    line.setAttribute("y1", p1.y);
    line.setAttribute("x2", p2.x);
    line.setAttribute("y2", p2.y);
    line.setAttribute("stroke", isHighlighted ? "#3b82f6" : "#ccc");
    line.setAttribute("stroke-width", isHighlighted ? "5" : "2");
    svg.appendChild(line);

    const midX = (p1.x + p2.x) / 2;
    const midY = (p1.y + p2.y) / 2;
    const dx = p2.y - p1.y;
    const dy = p1.x - p2.x;
    const len = Math.sqrt(dx * dx + dy * dy);
    const offset = 12;
    const tx = midX + (dx / len) * offset;
    const ty = midY + (dy / len) * offset;

    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", tx);
    text.setAttribute("y", ty);
    text.setAttribute("fill", "#fff");
    text.setAttribute("font-size", "14");
    text.setAttribute("text-anchor", "middle");
    text.textContent = graph[u][v];
    svg.appendChild(text);
  }

  for (let i = 0; i < 10; i++) {
    const {x, y} = positions[i];
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", x);
    circle.setAttribute("cy", y);
    circle.setAttribute("r", 20);
    circle.setAttribute("fill", animPath.includes(i) ? "#3b82f6" : "#e2e8f0");
    circle.setAttribute("stroke", "#1e293b");
    circle.setAttribute("stroke-width", "2");
    svg.appendChild(circle);

    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", x);
    text.setAttribute("y", y + 6);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("font-size", "18");
    text.setAttribute("font-weight", "bold");
    text.setAttribute("fill", animPath.includes(i) ? "#fff" : "#000");
    text.textContent = i;
    svg.appendChild(text);

    if (distMap[i] !== undefined && distMap[i] !== Infinity) {
      const distText = document.createElementNS("http://www.w3.org/2000/svg", "text");
      distText.setAttribute("x", x);
      distText.setAttribute("y", y - 30);
      distText.setAttribute("text-anchor", "middle");
      distText.setAttribute("font-size", "14");
      distText.setAttribute("fill", "#38bdf8");
      distText.textContent = `d: ${distMap[i]}`;
      svg.appendChild(distText);
    }
  }
}

function fillSelects() {
  const startSel = document.getElementById("start");
  const endSel = document.getElementById("end");
  for (let i = 0; i < 10; i++) {
    const opt1 = document.createElement("option");
    opt1.value = i;
    opt1.textContent = i;
    const opt2 = opt1.cloneNode(true);
    startSel.appendChild(opt1);
    endSel.appendChild(opt2);
  }
  endSel.value = 9;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function runDijkstraStepByStep(start, end) {
  const dist = Array(10).fill(Infinity);
  const prev = Array(10).fill(null);
  const visited = Array(10).fill(false);
  const pq = new PriorityQueue();
  dist[start] = 0;
  pq.enqueue(start, 0);

  while (!pq.isEmpty()) {
    const u = pq.dequeue();
    if (visited[u]) continue;
    visited[u] = true;
    animPath.push(u);
    drawGraph([], dist);
    await sleep(800);

    for (let v = 0; v < 10; v++) {
      if (graph[u][v] !== Infinity && !visited[v]) {
        const alt = dist[u] + graph[u][v];
        if (alt < dist[v]) {
          dist[v] = alt;
          prev[v] = u;
          pq.enqueue(v, alt);
          drawGraph([], dist);
          await sleep(600); // slow down for distance update
        }
      }
    }
  }

  const path = [];
  for (let at = end; at !== null; at = prev[at]) path.push(at);
  path.reverse();

  if (path[0] === start) {
    let cost = 0;
    for (let i = 1; i < path.length; i++) cost += graph[path[i - 1]][path[i]];
    document.getElementById("pathDisplay").textContent =
      `Shortest Path: ${path.join(" â†’ ")} (Total Cost: ${cost})`;

    await animateFinalPath(path);
  } else {
    document.getElementById("pathDisplay").textContent = "No path found.";
  }
}

async function animateFinalPath(path) {
  let index = 1;
  const highlightedEdges = [];
  animPath = [path[0]];
  drawGraph(highlightedEdges);
  while (index < path.length) {
    highlightedEdges.push(`${path[index - 1]}-${path[index]}`);
    animPath.push(path[index]);
    drawGraph(highlightedEdges);
    index++;
    await sleep(600);
  }
}

document.addEventListener("DOMContentLoaded", () => {
  fillSelects();
  drawGraph();

  document.getElementById("run").onclick = () => {
    animPath = [];
    const start = +document.getElementById("start").value;
    const end = +document.getElementById("end").value;
    runDijkstraStepByStep(start, end);
  };

  document.getElementById("reset").onclick = () => {
    location.reload();
  };
});
</script>
</body>
</html>
